<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Serialization on Jozef Sukovsky</title>
    <link>https://sukovsky.com/tags/serialization/</link>
    <description>Recent content in Serialization on Jozef Sukovsky</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>Â© Jozef Sukovsky</copyright>
    <lastBuildDate>Thu, 09 May 2024 19:00:00 +0000</lastBuildDate>
    <atom:link href="https://sukovsky.com/tags/serialization/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python JSON de/serialization speed-up and its impact on Django performance</title>
      <link>https://sukovsky.com/posts/6-python-json-serializers-performance/</link>
      <pubDate>Thu, 09 May 2024 19:00:00 +0000</pubDate>
      <guid>https://sukovsky.com/posts/6-python-json-serializers-performance/</guid>
      <description>Intro This is a non-direct follow-up to Stress-testing Django, Django REST framework, FastAPI, Express.js, Go-chi and Axum.&#xA;The question we will answer is, how much can we squeeze from Django replacing the native json library. For most cases, standard json library does good enough. But sometimes, when we deal with huge payloads, it may be beneficial to do differently. In this article, we shall compare json, simplejson, orjson, python-rapidjson, ultrajson. Overall, there were some more, like hyperjson, perde, but such were already abandoned, or pyserde which I decided not to test because of a different usage pattern and the performance for this purpose wasn&amp;rsquo;t impressive.</description>
    </item>
  </channel>
</rss>
