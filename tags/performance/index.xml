<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Performance on Jozef Sukovsky</title>
    <link>https://sukovsky.com/tags/performance/</link>
    <description>Recent content in Performance on Jozef Sukovsky</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>Â© Jozef Sukovsky</copyright>
    <lastBuildDate>Thu, 09 May 2024 19:00:00 +0000</lastBuildDate>
    <atom:link href="https://sukovsky.com/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python JSON de/serialization speed-up and its impact on Django performance</title>
      <link>https://sukovsky.com/posts/6-python-json-serializers-performance/</link>
      <pubDate>Thu, 09 May 2024 19:00:00 +0000</pubDate>
      <guid>https://sukovsky.com/posts/6-python-json-serializers-performance/</guid>
      <description>&lt;h2 id=&#34;intro&#34;&gt;Intro&lt;/h2&gt;&#xA;&lt;p&gt;This is a non-direct follow-up to &lt;a href=&#34;https://sukovsky.com/posts/5-stress-testing-django-drf-fastapi-expressjs-go-chi-axum/&#34; title=&#34;article&#34;&gt;Stress-testing Django, Django REST framework, FastAPI, Express.js, Go-chi and Axum&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;The question we will answer is, how much can we squeeze from Django replacing the native json library. For most cases, standard json library does good enough. But sometimes, when we deal with huge payloads, it may be beneficial to do differently. In this article, we shall compare &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;simplejson&lt;/code&gt;, &lt;code&gt;orjson&lt;/code&gt;, &lt;code&gt;python-rapidjson&lt;/code&gt;, &lt;code&gt;ultrajson&lt;/code&gt;. Overall, there were some more, like &lt;code&gt;hyperjson&lt;/code&gt;, &lt;code&gt;perde&lt;/code&gt;, but such were already abandoned, or &lt;code&gt;pyserde&lt;/code&gt; which I decided not to test because of a different usage pattern and the performance for this purpose wasn&amp;rsquo;t impressive. Once we find the winner, we will replace the JsonResponse from the test setup from previous article and re-run the brute force load test.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
